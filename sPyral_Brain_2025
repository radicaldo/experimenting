import pygame
import numpy as np

# ======================== STUART–LANDAU SPIRAL BRAIN (2025 edition) ========================
# 35 oscillators → 2–5 armed logarithmic spirals that breathe forever
# No knife-edge parameters, no locking, no jitter — just living cortex
# =======================================================================================

N = 35
W, H = 1600, 900
DT = 0.08

# Hopf parameters (these are the canonical values used in real papers)
mu = 0.32         # positive growth → self-sustained oscillations
omega0 = 1.8      # base frequency (gamma-ish)
omega_grad = 0.25 # spatial gradient to break symmetry
c2 = 0.45         # non-isochrony parameter (phase–amplitude coupling)
K = 0.085         # coupling tuned so coherence hovers in spiral regime
phase_lag = 0.5   # Sakaguchi lag pushes rotating patterns
noise = 0.1       # small noise = biological realism + prevents perfect lock
radius = 0.5      # interaction radius
kernel_sigma = 0.27

# State: complex numbers = amplitude + phase in one variable (this is the trick)
z = np.random.randn(N) + 1j * np.random.randn(N)   # start with small random amplitudes
pos = np.random.uniform(-1, 1, (N, 2))
trails = [[] for _ in range(N)]
trail_len = 150
freq_noise = 0.12 * np.random.randn(N)

# Fractal dendrite (same as before)
def gen_dendrite(lv, start, ang, len_, d=0, segs=None, cols=None):
    if segs is None: segs = []
    if cols is None: cols = []
    if lv == 0: return segs, cols
    end = start + len_ * np.array([np.cos(ang), np.sin(ang)])
    segs.append((start.copy(), end.copy()))
    hue = d / 9
    cols.append((int(255*(0.5+0.5*np.cos(6.28*(hue+0.0)))), 
                 int(255*(0.5+0.5*np.cos(6.28*(hue+0.33)))), 
                 int(255*(0.5+0.5*np.cos(6.28*(hue+0.67))))))
    nl = len_ * 0.63
    gen_dendrite(lv-1, end, ang-np.pi/5.8, nl, d+1, segs, cols)
    gen_dendrite(lv-1, end, ang+np.pi/5.8, nl, d+1, segs, cols)
    return segs, cols

segs, cols = gen_dendrite(9, np.array([0., -1.15]), np.pi/2, 0.95)
tips = np.array([s[1] for s in segs])
act = np.zeros(len(tips))

def w2s(p): 
    return int((p[0]+1.2)*(W//2-50)/2.4 + 25), int((1.2-p[1])*(H-100)/2.4 + 50)
def w2r(p): 
    return int((p[0]+1.6)*(W//2-50)/3.2 + W//2+25), int((1.6-p[1])*(H-100)/3.2 + 50)

def intrinsic_freq(i):
    return omega0 + omega_grad * (0.8 * pos[i,0] - 0.4 * pos[i,1]) + freq_noise[i]

pygame.init()
screen = pygame.display.set_mode((W, H))
font = pygame.font.SysFont('consolas', 16)
clock = pygame.time.Clock()
frame = 0

while True:
    for e in pygame.event.get():
        if e.type == pygame.QUIT: pygame.quit(); exit()
        if e.type == pygame.KEYDOWN and e.key == pygame.K_SPACE:
            z = 0.3 * (np.random.randn(N) + 1j * np.random.randn(N))
            pos = np.random.uniform(-1, 1, (N, 2))
            act.fill(0)
            trails = [[] for _ in range(N)]
            freq_noise = 0.12 * np.random.randn(N)

    # ======================== Stuart–Landau core ========================
    for i in range(N):
        coupling = 0j
        weight = 0.0
        for j in range(N):
            if i == j:
                continue
            dist = np.linalg.norm(pos[i] - pos[j])
            if dist < radius:
                w = np.exp(-(dist**2) / (2 * kernel_sigma**2))
                coupling += w * z[j]
                weight += w
        if weight:
            coupling /= weight

        omega_i = intrinsic_freq(i)
        sl = ((mu + 1j*omega_i) - (1 + 1j*c2) * abs(z[i])**2) * z[i]
        dzdt = sl + K * (np.exp(1j*phase_lag) * coupling - z[i])
        dzdt += noise * (np.random.randn() + 1j * np.random.randn())
        z[i] += dzdt * DT

        # phase → velocity (position-dependent swirl bias breaks symmetry)
        phase_dir = np.angle(z[i]) + 0.55 * pos[i,0] - 0.32 * pos[i,1]
        amp_delta = np.clip(abs(z[i]) - 0.48, -0.3, 0.8)
        speed = 0.02 + 0.03 * amp_delta
        vel = speed * np.array([np.cos(phase_dir), np.sin(phase_dir)])
        pos[i] += vel * DT
        pos[i] = ((pos[i] + 1.2) % 2.4) - 1.2

        # tiny separation nudge
        sep = np.zeros(2)
        nsep = 0
        for j in range(N):
            if i != j:
                dvec = pos[i] - pos[j]
                d = np.linalg.norm(dvec)
                if 0.01 < d < 0.19:
                    sep += dvec / d
                    nsep += 1
        if nsep: pos[i] += sep / nsep * 0.008

        # dendrite touch
        for k, t in enumerate(tips):
            if np.linalg.norm(pos[i] - t) < 0.15:
                act[k] = min(1.0, act[k] + 0.38)

        trails[i].append(pos[i].copy())
        if len(trails[i]) > trail_len: trails[i].pop(0)
    # =====================================================================

    screen.fill((0,0,30))
    pygame.draw.line(screen, (50,50,100), (W//2,0), (W//2,H), 2)

    # trails
    for i in range(N):
        for j in range(1, len(trails[i])):
            a = j / trail_len
            p1 = w2s(trails[i][j-1])
            p2 = w2s(trails[i][j])
            pygame.draw.line(screen, (0, int(255*a), int(180*a)), p1, p2, 2)

    # agents (size = amplitude)
    for i in range(N):
        px, py = w2s(pos[i])
        amp = min(6, 2.8 + 4.2*abs(z[i]))
        pygame.draw.circle(screen, (0,255,150), (px,py), int(amp))
        pygame.draw.circle(screen, (255,255,255), (px,py), int(amp), 1)

    # dendrite + glow
    for (s,e), c in zip(segs, cols):
        pygame.draw.line(screen, c, w2r(s), w2r(e), 2)
    for k, t in enumerate(tips):
        if act[k] > 0.05:
            px, py = w2r(t)
            intens = int(act[k]*255)
            rad = int(4 + act[k]*11)
            pygame.draw.circle(screen, (intens, intens//3, 0), (px,py), rad)
    act *= 0.94

    coh = np.abs(np.mean(z / abs(z + 1e-9)))
    txt = font.render(f"Coherence {coh:.3f}   Active {int(np.sum(act>0.1))}/{len(tips)}", True, (0,255,255))
    screen.blit(txt, (10, H-40))

    pygame.display.flip()
    clock.tick(60)
    frame += 1
